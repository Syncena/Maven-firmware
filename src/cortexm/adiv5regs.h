/*
 * Copyright (c) 2022, Steve C. Woodford.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef ADIV5REG_H
#define ADIV5REG_H

/*
 * Debug port ACK responses
 */
#define	DP_ACK_OK	(1u << 0)	/* Generated by DP */
#define	DP_ACK_WAIT	(1u << 1)	/* Generated by DP */
#define	DP_ACK_FAULT	(1u << 2)	/* Generated by DP */
#define	DP_ACK_PARITY	(1u << 3)	/* Parity error on read */

/*
 * Convert JTAG_DP_ACK to the above
 */
#define	JTAG_DP_ACK_NORMALISE(a)	(((a) & 0x3u) ^ 0x3u)

/*
 * Debug port request bits
 */
#define	DP_REQ_APnDP	(1u << 0)
#define	DP_REQ_RnW	(1u << 1)
#define	DP_REQ_A2	(1u << 2)
#define	DP_REQ_A3	(1u << 3)
#define	DP_REG_MASK	0x0fu

/*
 * JTAG-DP Instruction Registers
 */
#define	JTAG_DP_IR_ABORT	0xf8u
#define	JTAG_DP_IR_DPACC	0xfau
#define	JTAG_DP_IR_APACC	0xfbu

/*
 * Construct a 35-bit value for DR
 */
#define	JTAG_DP_CONSTRUCT_DR(bits,req,dat)				\
	do {								\
		(bits)[0] = (((req) >> 1) & 0x7u) | ((dat) << 3);	\
		(bits)[1] = (dat) >> 29;				\
	} while (/*CONSTCOND*/0)
#define	JTAG_DP_DECONSTRUCT_DR(bits,ack,dat)				\
	do {								\
		uint32_t _d = (bits)[0];				\
		ack = JTAG_DP_ACK_NORMALISE(_d);			\
		dat = (_d >> 3) | ((bits)[1] << 29);			\
	} while (/*CONSTCOND*/0)

/*
 * Debug port registers
 */
/* Bank 0 / X */
#define	DP_REG_DPIDR		0x00u	/* DPv1/2: Read-only */
#define	DP_REG_ABORT		0x00u	/*         Write-only */
#define	DP_REG_CTRL_STAT	0x04u	/*         Read/write */
#define	DP_REG_RESEND		0x08u	/* DPv1/2: Read-only */
#define	DP_REG_SELECT		0x08u	/*         Write-only */
#define	DP_REG_RDBUFF		0x0cu	/*         Read-only */
#define	DP_REG_TARGETSEL	0x0cu	/* DPv2:   Write-only */
/* Other Banks */
#define	DP_REG_DLCR		0x14u	/* DPv1/2: Bank 1: Read/write */
#define	DP_REG_TARGETID		0x24u	/* DPv2:   Bank 2: Read-only */
#define	DP_REG_DLPIDR		0x34u	/* DPv2:   Bank 3: Read-only */
#define	DP_REG_EVENTSTAT	0x44u	/* DPv2:   Bank 4: Read-only */

/* Bit definitions for DP_REG_DPIDR */
#define	DP_DPIDR_DESIGNER(idr)	((unsigned int)(((idr) >> 1) & 0x7ffu))
#define	DP_DPIDR_VERSION(idr)	((unsigned int)(((idr) >> 12) & 0xfu))
#define	DP_DPIDR_MIN(idr)	((unsigned int)(((idr) >> 16) & 0x1u))
#define	DP_DPIDR_PARTNO(idr)	((unsigned int)(((idr) >> 20) & 0xffu))
#define	DP_DPIDR_REVISION(idr)	((unsigned int)(((idr) >> 28) & 0xfu))

/* Bit definitions for DP_REG_ABORT */
#define	DP_ABORT_DAPABORT	(1u << 0)
#define	DP_ABORT_STKCMPCLR	(1u << 1)
#define	DP_ABORT_STKERRCLR	(1u << 2)
#define	DP_ABORT_WDERRCLR	(1u << 3)
#define	DP_ABORT_ORUNERRCLR	(1u << 4)

/* Bit definitions for DP_REG_CTRL_STAT */
#define	DP_CTRL_STAT_ORUNDETECT		(1u << 0)
#define	DP_CTRL_STAT_STICKYORUN		(1u << 1)
#define	DP_CTRL_STAT_TRNMODE_NORMAL	(0u << 2)
#define	DP_CTRL_STAT_TRNMODE_VERIFY	(1u << 2)
#define	DP_CTRL_STAT_TRNMODE_COMPARE	(2u << 2)
#define	DP_CTRL_STAT_STICKYCMP		(1u << 4)
#define	DP_CTRL_STAT_STICKYERR		(1u << 5)
#define	DP_CTRL_STAT_READOK		(1u << 6)
#define	DP_CTRL_STAT_WDATAERR		(1u << 7)
#define	DP_CTRL_STAT_MASKLANE_MASK	(0xfu << 8)
#define	DP_CTRL_STAT_MASKLANE_SHIFT	8
#define	DP_CTRL_STAT_TRNCNT_MASK	(0xfffu << 12)
#define	DP_CTRL_STAT_TRNCNT_SHIFT	12
#define	DP_CTRL_STAT_CDBGRSTREQ		(1u << 26)
#define	DP_CTRL_STAT_CDBGRSTACK		(1u << 27)
#define	DP_CTRL_STAT_CDBPWRUPREQ	(1u << 28)
#define	DP_CTRL_STAT_CDBPWRUPACK	(1u << 29)
#define	DP_CTRL_STAT_CSYSWRUPREQ	(1u << 30)
#define	DP_CTRL_STAT_CSYSWRUPACK	(1u << 31)
/*
 * Note: DP_CTRL_STAT_STICKYORUN, DP_CTRL_STAT_STICKYCMP,
 * DP_CTRL_STAT_STICKYERR, and DP_CTRL_STAT_WDATAERR are
 * used in the return value of adiv5_dp_clear_error().
 * In addition, DP_CTRL_STAT_ORUNDETECT is used to
 * indicate timeout waiting for DP_ACK_OK.
 */

/* Bit definitions for DP_REG_SELECT */
#define	DP_SELECT_DPBANKSEL_MASK	0x0fu
#define	DP_SELECT_DPBANKSEL_SHIFT	0
#define	DP_SELECT_APBANKSEL_MASK	0xf0u
#define	DP_SELECT_APBANKSEL_SHIFT	4
#define	DP_SELECT_APSEL_MASK		0xff000000u
#define	DP_SELECT_APSEL_SHIFT		24

/* Bit definitions for DP_REG_DLCR */
#define	DP_DLCR_TURNAROUND(n)		(((uint32_t)(n)) << 8)
#define	DP_DLCR_TURNAROUND_MASK		(0x3u << 8)

/* Bit definitions for DP_REG_DLPIDR */
#define	DP_DLPIDR_PROTVSN(n)		((n) & 0x0fu)
#define	DP_DLPIDR_TINSTANCE(n)		(((n) >> 28) & 0x0fu)

/* Bit definitions for DP_REG_TARGETID */
#define	DP_TARGETID_TDESIGNER(n)	(((n) >> 1) & 0x7ffu)
#define	DP_TARGETID_TPARTNO(n)		(((n) >> 12) & 0xffffu)
#define	DP_TARGETID_TINSTANCE(n)	(((n) >> 28) & 0x0fu)
#define	DP_TARGETID_MASK		0x0fffffffu

/* Bit definitions for DP_REG_TARGETSEL */
#define	DP_TARGETSEL_TINSTANCE(n)	(((n) >> 28) & 0x0fu)
#define	DP_TARGETSEL(tid,inst)		(((tid) & 0x0ffffffe) | 0x1u | \
					 (((inst) & 0x0fu) << 28))

/*
 * The 'reg' parameter of adiv5_dp_read()/adiv5_dp_write() also encodes the
 * APSEL and AP register bits. Use the following macro to embed the bits
 * correctly. For example: DP_ENCODE_APSEL(AP_REG_IDR, ap_sel).
 */
#define	DP_ENCODE_APSEL(r,s)		((((r)|DP_REQ_APnDP) & 0x00ffffffu) | \
					 (((uint32_t)(s)) << 24))

/*
 * Access Port Register.
 * This is the only register common to all types of AP.
 *
 * The value of this register is passed as a parameter to AP
 * attach routines.
 */
#define AP_REG_IDR			0xfcu

/* Format of the AP_IDR register */
#define AP_IDR_TYPE(idr)		((unsigned int)((idr) & 0xfu))
#define	 AP_IDR_TYPE_COM_AP		0x0u
#define	 AP_IDR_TYPE_AMBA_AHB3		0x1u
#define	 AP_IDR_TYPE_AMBA_APB2_APB3	0x2u
#define	 AP_IDR_TYPE_AMBA_AXI3_AXI4	0x4u
#define	 AP_IDR_TYPE_AMBA_AHB5		0x5u
#define	 AP_IDR_TYPE_AMBA_APB4		0x6u
#define AP_IDR_VARIANT(idr)		((unsigned int)(((idr) >> 4) & 0xfu))
#define AP_IDR_CLASS(idr)		((unsigned int)(((idr) >> 13) & 0xfu))
#define AP_IDR_DESIGNER(idr)		((unsigned int)(((idr) >> 17) & 0x7ffu))
#define AP_IDR_REVISION(idr)		((unsigned int)(((idr) >> 28) & 0xfu))

/* ARM's designer ID */
#define	AP_IDR_DESIGNER_ARM		0x23bu

/* Classes of Access Port */
#define	AP_CLASS_UNDEFINED		0x0
#define	AP_CLASS_MEM			0x8


/*---------------------------------------------------------------------------*/
/*
 * MEM-AP registers
 */

#define	ADIV5_MEM_AP_REG_CSW			0x00u
#define	ADIV5_MEM_AP_REG_TAR			0x04u
#define	ADIV5_MEM_AP_REG_TAR_MSW		0x08u
#define	ADIV5_MEM_AP_REG_DRW			0x0cu
#define	ADIV5_MEM_AP_REG_BD(n)			(0x10u + (4 * (n))
#define	ADIV5_MEM_AP_REG_MBT			0x20u
#define	ADIV5_MEM_AP_REG_BASE_MSW		0xf0u
#define	ADIV5_MEM_AP_REG_CFG			0xf4u
#define	ADIV5_MEM_AP_REG_BASE			0xf8u
#define	ADIV5_MEM_AP_REG_IDR			0xfcu

/* Bit definitions for ADIV5_MEM_AP_REG_CSW */
#define	ADIV5_MEM_AP_CSW_SIZE_MASK		(0x7u << 0)
#define	ADIV5_MEM_AP_CSW_SIZE_SHIFT		0
#define	ADIV5_MEM_AP_CSW_SIZE(c)		((c) & 0x7u)
#define	ADIV5_MEM_AP_CSW_SIZE_BYTE		0
#define	ADIV5_MEM_AP_CSW_SIZE_HALF_WORD		1
#define	ADIV5_MEM_AP_CSW_SIZE_WORD		2	/* 32-bits */
#define	ADIV5_MEM_AP_CSW_SIZE_DOUBLE_WORD	3
#define	ADIV5_MEM_AP_CSW_SIZE_128_BITS		4
#define	ADIV5_MEM_AP_CSW_SIZE_256_BITS		5
#define	ADIV5_MEM_AP_CSW_ADDRINC_MASK		(0x3u << 4)
#define	ADIV5_MEM_AP_CSW_ADDRINC_SHIFT		4
#define	ADIV5_MEM_AP_CSW_ADDRINC_OFF		0
#define	ADIV5_MEM_AP_CSW_ADDRINC_SINGLE		1
#define	ADIV5_MEM_AP_CSW_ADDRINC_PACKED		2
#define	ADIV5_MEM_AP_CSW_DEVICE_EN(c)		(((c) & (1u << 6)) != 0)
#define	ADIV5_MEM_AP_CSW_TRINPROG(c)		(((c) & (1u << 7)) != 0)
#define	ADIV5_MEM_AP_CSW_MODE_MASK		(0xfu << 8)
#define	ADIV5_MEM_AP_CSW_MODE_SHIFT		8
#define	ADIV5_MEM_AP_CSW_MODE_BASIC		0
#define	ADIV5_MEM_AP_CSW_MODE_BARRIER		1
#define	ADIV5_MEM_AP_CSW_TYPE_MASK		(0xfu << 12)
#define	ADIV5_MEM_AP_CSW_TYPE_SHIFT		12
#define	ADIV5_MEM_AP_CSW_SPIDEN(c)		(((c) & (1u << 23)) != 0)
#define	ADIV5_MEM_AP_CSW_MASK			0xffffffc8u
#define	ADIV5_MEM_AP_CSW_PROT_MASK		(0x7fu << 24)
#define	ADIV5_MEM_AP_CSW_PROT_SHIFT		24
#define	ADIV5_MEM_AP_CSW_DBGSWENABLE		(1u << 31)

/* Bit definitions for ADIV5_MEM_AP_REG_CFG */
#define	ADIV5_MEM_AP_CFG_BE(c)			(((c) & (1u << 0)) != 0)
#define	ADIV5_MEM_AP_CFG_LA(c)			(((c) & (1u << 1)) != 0)
#define	ADIV5_MEM_AP_CFG_LD(c)			(((c) & (1u << 2)) != 0)

/* Bit definitions for ADIV5_MEM_AP_REG_BASE */
#define	ADIV5_MEM_AP_BASE_BASEADDR_CLR_BITS	0x00000fffu
#define	ADIV5_MEM_AP_BASE_FORMAT_ADIv5(b)	(((b) & (1u << 1)) != 0)
#define	ADIV5_MEM_AP_BASE_DEBUG_PRESENT(b)	(((b) & (1u << 0)) != 0)
#define	ADIV5_MEM_AP_BASE_LEGACY_PRESENT(b)	((b) != 0xffffffffu)

/*
 * Component and Peripheral ID Registers
 */
#define	CPID_REG_PIDR0			0xfe0u
#define	CPID_REG_PIDR1			0xfe4u
#define	CPID_REG_PIDR2			0xfe8u
#define	CPID_REG_PIDR3			0xfecu
#define	CPID_REG_PIDR4			0xfd0u
#define	CPID_REG_PIDR5			0xfd4u	/* Reserved */
#define	CPID_REG_PIDR6			0xfd8u	/* Reserved */
#define	CPID_REG_PIDR7			0xfdcu	/* Reserved */
#define	CPID_REG_CIDR0			0xff0u
#define	CPID_REG_CIDR1			0xff4u
#define	CPID_REG_CIDR2			0xff8u
#define	CPID_REG_CIDR3			0xffcu

/* Bit definitions for CPID_REG_CIDR */
#define	ADIV5_CIDR_VALID(c)	(((c) & 0xffff0fffu) == 0xb105000du)
#define	ADIV5_CIDR_CLASS(c)	((unsigned int)(((c) >> 12) & 0xfu))

/* Values for ADIV5_CIDR_CLASS */
#define	ADIV5_CLASS_GENERIC_VERIFICATION	0
#define	ADIV5_CLASS_ROM_TABLE			1
#define	ADIV5_CLASS_CORESIGHT			9
#define	ADIV5_CLASS_PERIPHERAL_TEST_BLK		11
#define	ADIV5_CLASS_GENERIC_IP			14
#define	ADIV5_CLASS_CORELINK_ETC		15

/* CoreSight Class 0x9 Registers */
#define	ADIV5_CLASS9_DBGPCR(n)		(0xa00u + (4u * (n)))
#define	ADIV5_CLASS9_DBGPSR(n)		(0xa80u + (4u * (n)))
#define	ADIV5_CLASS9_SYSPCR(n)		(0xb00u + (4u * (n)))
#define	ADIV5_CLASS9_SYSPSR(n)		(0xb80u + (4u * (n)))
#define	ADIV5_CLASS9_PRIDR0		0xc00u
#define	ADIV5_CLASS9_DBGRSTRR		0xc10u
#define	ADIV5_CLASS9_DBGRSTAR		0xc14u
#define	ADIV5_CLASS9_SYSRSTRR		0xc18u
#define	ADIV5_CLASS9_SYSRSTAR		0xc1cu
#define	ADIV5_CLASS9_COM_PORT		0xd00u
#define	ADIV5_CLASS9_ITCTRL		0xf00u
#define	ADIV5_CLASS9_CLAIMSET		0xfa0u
#define	ADIV5_CLASS9_CLAIMCLR		0xfa4u
#define	ADIV5_CLASS9_DEVAFF0		0xfa8u
#define	ADIV5_CLASS9_DEVAFF1		0xfacu
#define	ADIV5_CLASS9_LAR		0xfb0u
#define	ADIV5_CLASS9_LSR		0xfb4u
#define	ADIV5_CLASS9_AUTHSTATUS		0xfb8u
#define	ADIV5_CLASS9_DEVARCH		0xfbcu
#define	ADIV5_CLASS9_DEVID2		0xfc0u
#define	ADIV5_CLASS9_DEVID1		0xfc4u
#define	ADIV5_CLASS9_DEVID		0xfc8u
#define	ADIV5_CLASS9_DEVTYPE		0xfccu

/* Bit definitions for ADIV5_CLASS9_DEVARCH */
#define	ADIV5_DEVARCH_ARCHITECT(d)	(((d) >> 21) & 0x7ffu)
#define	 ADIV5_DEVARCH_ARCHITECT_ARM	0x23bu
#define	ADIV5_DEVARCH_PRESENT(d)	(((d) >> 20) & 0x1u)
#define	ADIV5_DEVARCH_REVISION(d)	(((d) >> 16) & 0xfu)
#define	ADIV5_DEVARCH_ARCHID(d)		(((d) >> 0) & 0xffffu)
#define	 ADIV5_DEVARCH_ARCHID_ROM_TABLE	0xaf7u

#endif /* ADIV5REG_H */
